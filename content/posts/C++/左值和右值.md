+++
title = '左值和右值'
date = '2025-04-20T21:04:32+08:00'
categories = ["C/C++"]
tags = ["C/C++"]
# draft = true
+++

# 值类别

每个 C++ 表达式（带有操作数的操作符、字面量、变量名等）可按照两种独立的特性加以辨别：类型和值类别 (value category)。每个表达式都具有某种非引用类型，且每个表达式只属于三种基本值类别中的一种：纯右值 (prvalue)、亡值 (xvalue)、左值 (lvalue)。

- 泛左值 (glvalue)（“泛化 (generalized)”的左值）是一个表达式，其值可确定某个对象或函数的标识；
- 纯右值 (prvalue)（“纯 (pure)”的右值）是求值符合下列之一的表达式：
	- 计算某个运算符的操作数的值（这种纯右值没有结果对象）
	- 初始化某个对象（称这种纯右值有一个结果对象）。结果对象可以是变量，由 `new` 表达式创建的对象，由临时量实质化创建的临时对象，或者前述三类对象的成员。注意非 `void` 的弃值表达式有结果对象（即被实质化的临时量）。并且在作为 `decltype` 的操作数以外的情况下，每个类类型或数组类型的纯右值都有结果对象；
- 亡值 (xvalue)（“将亡 (expiring)”的值）是代表它的资源能够被重新使用的对象或位域的泛左值；
- 左值 (lvalue)（如此称呼的历史原因是，左值可以在赋值表达式的左边出现）是非亡值的泛左值；
- 右值 (rvalue)（如此称呼的历史原因是，右值可以在赋值表达式的右边出现）是纯右值或者亡值。

## 基本类别

### 左值

下列表达式是左值表达式：
- 变量、函数、模板形参对象 (C++20 起)或数据成员的名字，不论类型，例如 `std::cin` 或 `std::endl`。即使变量的类型是右值引用，由它的名字构成的表达式仍是左值表达式；
- 返回类型是左值引用的函数调用或重载运算符表达式，例如 `std::getline(std::cin, str)`、`std::cout << 1`、`str1 = str2` 或 `++it`；
- `a = b`，`a += b`，`a %= b`，以及所有其他内建的赋值及复合赋值表达式；
- `++a` 和 `--a`，内建的前置自增与前置自减表达式；
- `*p`，内建的间接寻址表达式；
- `a[n]` 和 `n[a]`，内建的下标表达式，当 `a[n]` 中的一个操作数是数组左值时 (C++11 起)；
- `a.m`，对象成员表达式，除了 `m` 是成员枚举项或非静态成员函数，或者 `a` 是右值而 `m` 是对象类型的非静态数据成员的情况；
- `p->m`，内建的指针成员表达式，除了 `m` 是成员枚举项或非静态成员函数的情况；
- `a.*mp`，对象的成员指针表达式，其中 `a` 是左值且 `mp` 是数据成员指针；
- `p->*mp`，内建的指针的成员指针表达式，其中 `mp` 是数据成员指针；
- `a, b`，内建的逗号表达式，其中 `b` 是左值；
- `a ? b : c`，对某些 `b` 和 `c` 的三元条件表达式（例如，当它们都是同类型左值时，但细节见定义）；
- 字符串字面量，例如 `"Hello, world!"`；
- 转换到左值引用类型的转型表达式，例如 `static_cast<int&>(x)`；
- 具有左值引用类型的非类型模板形参；
- 返回类型是到函数的右值引用的函数调用表达式或重载的运算符表达式；
- 转换到函数的右值引用类型的转型表达式，如 `static_cast<void (&&)(int)>(x)`。(C++11 起)

性质：
- 与泛左值相同（见下文）。
- 可以通过内建的取址运算符取左值的地址：`&++i[1]` 及 `&std::endl` 是合法表达式。
- 可修改的左值可用作内建赋值和内建复合赋值运算符的左操作数。
- 左值可以用来初始化左值引用；这会将一个新名字关联给该表达式所标识的对象。

### 纯右值

下列表达式是纯右值表达式：
- （除了字符串字面量之外的）字面量，例如 `42`、`true` 或 `nullptr`；
- 返回类型是非引用的函数调用或重载运算符表达式，例如 `str.substr(1, 2)`、`str1 + str2` 或 `it++`；
- `a++` 和 `a--`，内建的后置自增与后置自减表达式；
- `a + b`、`a % b`、`a & b`、`a << b`，以及其他所有内建的算术表达式；
- `a && b`、`a || b`、`!a`，内建的逻辑表达式；
- `a < b`、`a == b`、`a >= b` 以及其他所有内建的比较表达式；
- `&a`，内建的取地址表达式；
- `a.m`，对象成员表达式，其中 `m` 是成员枚举项或非静态成员函数；
- `p->m`，内建的指针成员表达式，其中 `m` 是成员枚举项或非静态成员函数；
- `a.*mp`，对象的成员指针表达式，其中 `mp` 是成员函数指针}；
- `p->*mp`，内建的指针的成员指针表达式，其中 `mp` 是成员函数指针；
- `a, b`，内建的逗号表达式，其中 `b` 是右值；
- `a ? b : c`，对某些 `b` 和 `c` 的三元条件表达式（细节见定义）；
- 转换到非引用类型的转型表达式，例如 `static_cast<double>(x)`、`std::string{}` 或 `(int)42`；
- `this` 指针；
- 枚举项;
- 具有标量类型的非类型模板形参；
- `lambda` 表达式，例如 `[](int x){ return x * x; }`；(C++11 起)
- `requires` 表达式，例如 `requires (T i) { typename T::type; }`；
- 概念的特化，例如 `std::equality_comparable<int>`。(C++20 起)

性质：
- 与右值相同（见下文）。
- 纯右值不具有多态：它所标识的对象的动态类型始终是该表达式的类型。
- 非类非数组的纯右值不能有 `cv` 限定，除非它被实质化以绑定到 `cv` 限定类型的引用 (C++17 起)。（注意：函数调用或转型表达式可能生成非类的 `cv` 限定类型的纯右值，但它的 `cv` 限定符通常被立即剥除。）
- 纯右值不能具有不完整类型（除了类型 `void`（见下文），或在 `decltype` 说明符中使用之外）
- 纯右值不能具有抽象类类型或它的数组类型。

### 亡值

下列表达式是亡值表达式：
- `a.m`，对象成员表达式，其中 `a` 是右值且 `m` 是对象类型的非静态数据成员；
- `a.*mp`，对象的成员指针表达式，其中 `a` 是右值且 `mp` 是数据成员指针；
- `a ? b : c`，对某些 `b` 和 `c` 的三元条件表达式（细节见定义）；
- 返回类型是对象的右值引用的函数调用或重载运算符表达式，例如 `std::move(x)`；
- `a[n]`，内建的下标表达式，它的操作数之一是数组右值；
- 转换到对象的右值引用类型的类型转换表达式，例如 `static_cast<char&&>(x)`；(C++11 起)
- 在临时量实质化后，任何指代该临时对象的表达式。(C++17 起)
- 有移动资格的表达式。(C++23 起)

性质：
- 与右值相同（见下文）。
- 与泛左值相同（见下文）。
- 特别是，与所有的右值类似，亡值可以绑定到右值引用上，而且与所有的泛左值类似，亡值可以是多态的，而且非类的亡值可以有 `cv` 限定。

## 混合类别

### 泛左值

泛左值表达式包括左值、亡值。

- 泛左值可以通过左值到右值、数组到指针或函数到指针隐式转换转换成纯右值。
- 泛左值可以是多态的：它标识的对象的动态类型不必是该表达式的静态类型。
- 泛左值可以具有不完整类型，只要表达式中容许。

### 右值

右值表达式包括纯右值、亡值。

- 右值不能由内建的取址运算符取地址：`&int()`、`&i++[3]`、`&42` 及 `&std::move(x)` 是非法的。
- 右值不能用作内建赋值运算符及内建复合赋值运算符的左操作数。
- 右值可以用来初始化 `const` 左值引用，这种情况下该右值所标识的对象的生存期被延长到该引用的作用域结尾。
- 右值可以用来初始化右值引用，这种情况下该右值所标识的对象的生存期被延长到该引用的作用域结尾。
- 当被用作函数实参且该函数有两种重载可用，其中之一接受右值引用的形参而另一个接受 `const` 的左值引用的形参时，右值将被绑定到右值引用的重载之上（从而，当复制与移动构造函数均可用时，以右值实参将调用它的移动构造函数，复制和移动赋值运算符与此类似）。

```C++
#include <iostream>

// 要求左值表达式
void print(int& t) {
	std::cout << "left value" << std::endl;
}

// 要求右值表达式，亡值、纯右值
void print(int&& t) {
	std::cout << "right value" << std::endl;
}

int main(int argc, char* argv[])
{
	int val{};
	int& val_lref = val;
	int&& val_rref = 0;

	// Use auto when you need a local copy,
	// this will never produce a reference
	auto&& type1 = std::move(val);		// 无引用
	auto&& type2 = std::move(val_lref);	// 左值引用
	auto&& type3 = std::move(val_rref);	// 右值引用

	// 右值表达式，（除了字符串字面量之外的）字面量，例如 42、true 或 nullptr
	print(0);

	// 右值表达式，a++ 和 a--，内建的后置自增与后置自减表达式
	print(val++);

	// 右值表达式，a && b、a || b、!a，内建的逻辑表达式
	print(val && val);

	// 亡值表达式，返回类型是对象的右值引用的函数调用或重载运算符表达式
	print(std::move(val));

	// 亡值表达式，转换到对象的右值引用类型的类型转换表达式
	print(static_cast<int&&>(val));

	std::cout << "---------------" << std::endl;

	// 完美转发
	print(std::forward<int>(val));		// 右值
	print(std::forward<int&>(val));		// 左值，触发引用折叠
	print(std::forward<int&&>(val));	// 右值，触发引用折叠

	// 引用折叠测试
	using type = int&&;
	using type_lref = type&;			// int&
	using type_rref = type&&;			// int&&

	return 0;
}
```